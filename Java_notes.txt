Intro to Java
  It is a simple programming language. Java makes writing, compiling, and debugging programming easy. It helps to create reusable code and modular programs. Java is a class-based, object-oriented programming language and is designed to have as few implementation dependencies as possible.
  write once run anywhere
  Java applications are compiled to byte code that can run on any Java Virtual Machine


Syntactical Similarities:
  1. Object-Oriented Programming: Both Java and C++ are object-oriented programming languages, and they support concepts such as classes, objects, inheritance, and polymorphism.
  2. Control Structures: Java and C++ have similar control structures, including if-else statements, for loops, while loops, and switch statements.
  3. Data Types: Both languages have similar basic data types, such as integers, floating-point numbers, characters, and booleans.

Syntactical Dissimilarities:
  1. Syntax and Naming Conventions: Java and C++ have different syntax and naming conventions. For example, in Java, classes are defined using the keyword "class," whereas in C++, the keyword "class" is used with additional syntax.
  2. Memory Management: Java uses automatic garbage collection to manage memory, while C++ requires manual memory management through the use of constructors, destructors, and memory allocation/deallocation operators like "new" and "delete."
  3. Pointers: C++ supports the use of pointers, allowing direct memory manipulation and dynamic memory allocation. Java, on the other hand, does not have explicit pointer manipulation and provides automatic memory management through references.
  4. Exception Handling: Both languages support exception handling, but the syntax and handling mechanisms differ. Java uses checked and unchecked exceptions, while C++ uses a try-catch block with specific exception types.
  5. Standard Libraries: Java and C++ have their own standard libraries with different functions and classes for various tasks. For example, Java has libraries like java.util and java.io, while C++ has libraries like std::vector and std::string.



Java directory
  The Java directory contains multiple folders and files, each with a specific purpose. Here is an overview of the main folders and files in a typical Java installation:

  bin: This folder contains the binary executables for the Java Development Kit (JDK) and the Java Runtime Environment (JRE), including the java, javac, and jar executables.

  conf: This folder contains configuration files for the JDK, JRE, and various tools.

  include: This folder contains header files and other files needed for compiling native code with the JDK.

  jmods: This folder contains modular JAR files that are used to create custom runtimes for Java applications.

  legal: This folder contains legal documents related to the use of the JDK and JRE.

  lib: This folder contains the library files for the JDK and JRE, including the rt.jar file that contains the core Java classes.

  man: This folder contains manual pages for various Java tools.

  src.zip: This file contains the source code for the Java standard library, which can be used for reference or for debugging purposes.

  README: This file contains information about the contents of the Java directory and how to use the JDK and JRE.

  LICENSE: This file contains the terms of the Oracle Binary Code License Agreement, which governs the use of the JDK and JRE.

  THIRDPARTYLICENSEREADME-JAVAFX.txt: This file contains information about third-party components used in the JavaFX libraries.

  release: This file contains information about the version and release of the JDK.

  In summary, the Java directory contains folders and files related to the JDK and JRE, including binaries, configuration files, library files, source code, and legal documents. These files and folders provide the tools and resources needed for developing, running, and debugging Java applications.

Features
  1. Platform Independent:  Compiler converts source code to bytecode and then the JVM executes the bytecode generated by the compiler. This bytecode can run on any platform be it Windows, Linux, or macOS which means if we compile a program on Windows, then we can run it on Linux and vice versa. Each operating system has a different JVM, but the output produced by all the OS is the same after the execution of bytecode. That is why we call java a platform-independent language.

  2. Object-Oriented Programming Language:  Organizing the program in the terms of collection of objects is a way of object-oriented programming, each of which represents an instance of the class.

  The four main concepts of Object-Oriented programming are:
  Abstraction
  Encapsulation
  Inheritance
  Polymorphism

  3. Simple:  Java is one of the simple languages as it does not have complex features like pointers, operator overloading, multiple inheritances, and Explicit memory allocation. 

  4. Robust:  Java language is robust which means reliable. It is developed in such a way that it puts a lot of effort into checking errors as early as possible, that is why the java compiler is able to detect even those errors that are not easy to detect by another programming language. The main features of java that make it robust are garbage collection, Exception Handling, and memory allocation.

  5. Secure:  In java, we don’t have pointers, so we cannot access out-of-bound arrays i.e it shows ArrayIndexOutOfBound Exception if we try to do so. That’s why several security flaws like stack corruption or buffer overflow are impossible to exploit in Java. Also java programs run in an environment that is independent of the os(operating system) environment which makes java programs more secure .

  6. Distributed:  We can create distributed applications using the java programming language. Remote Method Invocation and Enterprise Java Beans are used for creating distributed applications in java. The java programs can be easily distributed on one or more systems that are connected to each other through an internet connection.

  7. Multithreading:  Java supports multithreading. It is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of the CPU.

  8. Portable:  As we know, java code written on one machine can be run on another machine. The platform-independent feature of java in which its platform-independent bytecode can be taken to any platform for execution makes java portable.

  9. High Performance: Java architecture is defined in such a way that it reduces overhead during the runtime and at some time java uses Just In Time (JIT) compiler where the compiler compiles code on-demand basics where it only compiles those methods that are called making applications to execute faster.

  10. Dynamic flexibility: Java being completely object-oriented gives us the flexibility to add classes,  new methods to existing classes and even create new classes through sub-classes. Java even supports functions written in other languages such as C, C++ which are referred to as native methods.

  11. Sandbox Execution: Java programs run in a separate space that allows user to execute their applications without affecting the underlying system with help of a bytecode verifier. Bytecode verifier also provides additional security as its role is to check the code for any violation of access.

  12. Write Once Run Anywhere: As discussed above java application generates a ‘.class’ file which corresponds to our applications(program) but contains code in binary format. It provides ease t architecture-neutral ease as bytecode is not dependent on any machine architecture. It is the primary reason java is used in the enterprising IT industry globally worldwide.

  13. Power of compilation and interpretation: Most languages are designed with purpose either they are compiled language or they are interpreted language. But java integrates arising enormous power as Java compiler compiles the source code to bytecode and JVM  executes this bytecode to machine OS-dependent executable code.  

Compiler
  it is a program that takes source code in high lavel langauge (human understandable language) and converts it into byte code.
  refer image in folder

Interpreter
  it is also a program that takes source code in high lavel langauge (human understandable language) and converts it into byte code. But it will not return you any executabe unlike compiler. It will actualy translate and execute the code immediately giving the output of program.
  refer image in folder

Diff bet compiler and interpreter
  Behavior
    1. compiler translated source code to machine code but does not executes the translated code.
    2. An interpreter translates and then execute cources code on the fly without giving a target executable to run by a programmer.

  Performance
    1. the translation of high level code to machine code is slow but subsequent execution is fast.
    2. An interpreter starts executing the source program immediately, but the execution is slow as translation is done on the fly.

What Java uses
  Java uses both, it uses compiler to convert the source code to byte code and interpreter to execute the byte code.

JDK
  It is SDK with combination of tools and libraries for compiling, debugging, testing and executing java programs.
  Tools in JDK:
    1. Javac
        Its a compiler that convert source code to byte code. It is also a type of command in cmd.
    2. jdb
        Java debugge is tool to find and fix errors

JRE
  It contains all the tools and libraries required for running the compiled Bytecode. 
  Utilities included in JRE
  1. Java: Its a command line tool which is responsible for launching the JVM.
  2. Librabies: Eg- collection framework etc.

JVM
  When you try to execute a program on CPU you have to execute JVM i.e interpreter. interpreter is platform dependent, for every platform there is different interpreter. JVM should know the OS and real processor. You can also say JVM = interpreter + actual platform.
  refer images for relation between JDK, JRE, JVM and there architecture. 

Structure of class
  A class is a template for creating a particular form of object.
  elements:
    Attributes
    constructor
    distructor
    getter methods 
    setter methods
    Object

Java Variables


  Eg: int data=50;//Here data is variable  

  There are three types of variables in java: local, instance and static

  1) Local Variable
    A variable declared inside the body of the function is called local variable. You can use this variable only within that function and the other functions in the class aren't even aware that the variable exists.
    A local variable cannot be defined with "static" keyword.

  2) Instance Variable
    A variable declared inside the class but outside the body of the function, is called an instance variable. It is not declared as static.
    It is called an instance variable because its value is instance-specific and is not shared among instances.

  3) Static variable
    A variable that is declared as static is called a static variable. It cannot be local. You can create a single copy of the static variable and share it among all the instances of the class. Memory allocation for static variables happens only once when the class is loaded in the memory.

Data Types in Java

  Data types specify the different sizes and values that can be stored in the variable. There are two types of data types in Java:
  Primitive data types: The primitive data types include boolean, char, byte, short, int, long, float and double.
  Non-primitive data types: The non-primitive data types include Classes, Interfaces, and Arrays.

  Boolean Data Type
    The Boolean data type is used to store only two possible values: true and false. This data type is used for simple flags that track true/false conditions.
    The Boolean data type specifies one bit of information

  Byte Data Type
    The byte data type is an example of primitive data type. It isan 8-bit signed integer. Its value-range lies between -128 to 127 (inclusive). Its minimum value is -128 and maximum value is 127. Its default value is 0.
    The byte data type is used to save memory in large arrays where the memory savings is most required. It saves space because a byte is 4 times smaller than an integer.

  Short Data Type
    The short data type is a 16-bit signed integer. Its value-range lies between -32,768 to 32,767 (inclusive). Its minimum value is -32,768 and maximum value is 32,767. Its default value is 0.
    The short data type can also be used to save memory just like byte data type. A short data type is 2 times smaller than an integer.

  Int Data Type
    The int data type is a 32-bit signed integer.
    The int data type is generally used as a default data type for integral values unless if there is no problem about memory.

  Long Data Type
    The long data type is a 64-bit signed integer.
    The long data type is used when you need a range of values more than those provided by int.

  Float Data Type
    The float data type is a 32-bit floating point.Its value range is unlimited. It is recommended to use a float (instead of double) if you need to save memory in large arrays of floating point numbers. The float data type should never be used for precise values, such as currency. Its default value is 0.0F.
  
  Double Data Type
    The double data type is a 64-bit floating point. Its value range is unlimited. The double data type is generally used for decimal values just like float. The double data type also should never be used for precise values, such as currency. Its default value is 0.0d.

  Char Data Type
    The char data type is used to store characters.
  
Data Compatibility 

  It refers to the ability to assign or pass values between different data types in a consistent and predictable manner. Java provides several mechanisms for data compatibility, such as implicit type conversion, explicit type casting, and promotion.
  1. Implicit Type Conversion:
  Java allows automatic conversion of values from one data type to another when the destination type can accommodate the value without loss of precision or information.

  int myInt = 10;
  double myDouble = myInt; // Implicit conversion from int to double

  2. Explicit Type Casting:
  Java also supports explicit type casting, which allows you to convert a value from one data type to another explicitly. This is done by specifying the target type in parentheses before the value being casted.

  double myDouble = 10.5;
  int myInt = (int) myDouble; // Explicit casting from double to int


  3. Promotion:
  Promotion occurs when smaller data types are automatically converted to larger data types to perform operations without loss of precision.
  int myInt = 5;
  double myDouble = 2.5;
  double result = myInt + myDouble; // Promotion of int to double

Array

  Java array is an object which contains elements of a similar data type. Additionally, The elements of an array are stored in a contiguous memory location. It is a data structure where we store similar elements. We can store only a fixed set of elements in a Java array.

  Types of Array in java
    There are two types of array.
     Single Dimensional Array
     Multidimensional Array

Operator
  Unary Operator
    ++ --
  Arithmetic Operator
    *, /, %,+, -
  Relational Operator
    <, >, <=, >=, ==, !=
  Logical Operator
    &&  ||
  Ternary Operator and
    ? :
  Assignment Operator
    = += -= *= /= %=

Control statements
  Java provides statements that can be used to control the flow of Java code. Such statements are called control flow statements. It is one of the fundamental features of Java, which provides a smooth flow of program.

  Decision Making statements
    if statements
    switch statement
  Loop statements
    do while loop
    while loop
    for loop
    for-each loop
  Jump statements
    break statement
    continue statement

09-02-2023
Static variables and methods
  If we want a variable to be same for all objects we use static variables 
  Static variables can be accessed directly witout using object
  How to access:
    if its in the single class -> directly access
    if its in the different class -> access by class name

Static block
  used to initialize static variables
  we can only access static elements in static blocks
  the contain are executed without any explicit call

Accessing static variables and methods of different class
  Access with the help of class name
  Eg: className.staticVariable

Introduction to reference data types

Reference variables and methods
  They does'nt store the object they store address where objects are stored in the memory
  they don’t have a fix size.  

Difference between reference data types and primitive data types
  Reference Type	
  It is not pre-defined except the String.	
  All reference type begins with Uppercase letter.	
  Non-primitive types have all the same size.	
  It is used to invoke or call methods.	
  It can be null.	
  Examples of reference data types are class, Arrays, String, Interface, etc.
  JVM allocates 8 bytes for each reference variable, by default.

  Primitive Type
  It is pre-defined in Java.
  All primitive type begins with a lowercase letter.
  The size of a primitive type depends on the data type.
  We cannot invoke the method with a primitive type.
  It cannot be null. It always has value.
  Examples of primitive data types are int, float, double, Boolean, long, etc.
  Its size depends on the data type.

Difference between reference variable and static variable

Constructors
  A public constructor can be accessed by any class, regardless of its location in the class hierarchy.
  A protected constructor can only be accessed by classes in the same package or by subclasses of the class in which the constructor is declared.
  A private constructor can only be accessed by other constructors within the same class.

  a constructor in Java cannot be declared as static or final.
  The purpose of a constructor is to initialize an object's state and allocate memory for the object. Since static and final are not related to an object's state or memory allocation, they are not applicable to constructors.
  However, you can use the final keyword with constructor parameters to enforce immutability in the created object
  https://www.javatpoint.com/java-constructor

initializing reference variables using constructors

Pass by value v/s pass by reference
  Pass-by-Value:
  In Java, when you pass a variable as an argument to a method, a copy of the value of the variable is created and passed to the method. The method operates on the copy, not the original variable. Any modifications made to the copy of the variable inside the method do not affect the original variable outside the method.

  Ex: 
  public class PassByValueExample {
    public static void modifyValue(int num) {
        num = 20; // Modifying the copy of the value
    }

    public static void main(String[] args) {
        int number = 10;
        modifyValue(number); // Passing the value of 'number'
        System.out.println(number); // Output: 10, original value remains unchanged
    }
  }


  Pass-by-Reference:
  In some programming languages, such as C++, there is a concept of pass-by-reference, where a method can directly modify the original variable. However, in Java, there is no direct pass-by-reference. Instead, you can achieve similar effects by passing objects as arguments. When an object is passed as an argument, the reference to the object is copied, not the object itself. Therefore, modifications made to the object's properties or fields within the method will affect the original object.

  Ex:
    public class PassByReferenceExample {
    public static void modifyValue(StringBuilder sb) {
        sb.append(" World!"); // Modifying the object referred to by 'sb'
    }

    public static void main(String[] args) {
        StringBuilder message = new StringBuilder("Hello");
        modifyValue(message); // Passing the reference to 'message'
        System.out.println(message); // Output: Hello World!, original object modified
    }
  }


  https://www.youtube.com/watch?v=yy7agQfkC9c&list=PLEbnTDJUr_Iekh7CGDsDizndTgBFruHn1&index=6


Re-assigning a reference variable

Passing reference variable to method

Initializing reference variable of different class

Heap memory and stack memory

  Heap
    In Java, heap memory is used for storing objects and data that are dynamically allocated at runtime. The JVM manages the heap memory, which means that the programmer does not need to explicitly allocate or deallocate memory on the heap.
    When an object is created in Java, it is allocated on the heap memory. The JVM tracks the objects on the heap using a data structure called the "heap space". The heap space is divided into multiple generations, with objects that are newer and more frequently accessed being placed in the younger generations, and objects that are older and less frequently accessed being placed in the older generations.
    Java heap memory is managed using a process called "garbage collection". Garbage collection is a process that identifies and releases unused objects in the heap memory to free up space for new objects. The garbage collector periodically scans the heap space and identifies objects that are no longer in use. The garbage collector then releases the memory occupied by these objects, making it available for new objects to be allocated.
    Java heap memory can be configured using JVM command-line options to set the initial and maximum size of the heap memory. If an application needs more memory than what is available on the heap, the JVM may throw an OutOfMemoryError.
    It is important to note that objects on the heap are accessible by multiple threads. To ensure thread-safety, programmers must use synchronization techniques to avoid data races and ensure that objects are accessed in a safe and consistent manner.
    In summary, heap memory in Java is used for storing dynamically allocated objects and data. The JVM manages the heap memory using a data structure called the heap space and a garbage collector to release unused objects. The programmer does not need to explicitly allocate or deallocate memory on the heap. Heap memory can be configured using JVM command-line options and is accessible by multiple threads, requiring synchronization techniques to ensure thread-safety.


  Stack 
    In Java, stack memory is used for storing method-specific variables and data, and is used for method execution. When a method is called, a new block of memory is created in the stack for that method's variables and data, and when the method finishes execution, the memory is automatically released.
    The Java Virtual Machine (JVM) divides memory into two types: heap memory and stack memory. Heap memory is used for storing objects that are dynamically allocated, while stack memory is used for storing primitive types and references to objects.
    Each thread in a Java program has its own stack memory, which is used to store the method calls made by that thread. When a method is called, its arguments and local variables are pushed onto the stack. The method then executes, and when it is finished, the memory used by the method is popped off the stack.
    Java stack memory is managed automatically by the JVM, and there is no need for the programmer to explicitly allocate or deallocate memory on the stack. The size of the stack is determined by the JVM and can be adjusted using command-line options.
    Stack memory is typically faster to access than heap memory, as it is located in the processor's cache memory, which allows for quicker access times. However, the amount of memory available on the stack is usually limited, and large objects or data structures cannot be stored on the stack.
    In summary, stack memory in Java is used for storing method-specific variables and data, and is automatically managed by the JVM. Each thread has its own stack memory, and the size of the stack is determined by the JVM. Stack memory is typically faster to access than heap memory, but has limited capacity.

    they both are stored in RAM

  
  https://www.youtube.com/watch?v=_GK3WoFFKUE

final keyword

OOPs
  Inheritance
    super calls the constructor of parent class
  Polymorphism
  Encapsulation
  Abstraction


private data members can be accessed by getters and setters

default access spescifier are only allowed to access in same package

Compile-time polymorphism: Compile-time polymorphism occurs when a method is overloaded with different parameters or return types. During the compilation phase, the compiler decides which method to call based on the method signature. The signature of a method includes the method name, the number and types of its parameters, and its return type. The method overloading allows us to use the same method name to perform different tasks. The method to be called is determined based on the number and type of arguments passed at compile-time.

Run-time polymorphism: Run-time polymorphism occurs when a method is overridden in a subclass. In other words, when a method in the superclass has the same signature as a method in a subclass, the method in the subclass overrides the method in the superclass. The method to be called is determined based on the actual type of the object at runtime.


Overloading:

  The method in the same class or subclass must have the same name as the method being overloaded.
  The method must have a different number or types of parameters than the method being overloaded.
  The method can have the same or a different return type as the method being overloaded.
  The method can throw the same or different exceptions as the method being overloaded.

Overriding:
  The method in the subclass must have the same name, return type, and parameters as the method in the superclass.
  The method in the subclass cannot have a lower access level than the method in the superclass (e.g., a public method in the superclass cannot be overridden as a private method in the subclass).
  The method in the subclass can have a higher access level than the method in the superclass (e.g., a protected method in the superclass can be overridden as a public method in the subclass).
  

"super" keyword:
  It is a refrence variable which is used to refer immediate parent class object. 
  "super" keyword is used to refer to the parent class of the current class.
  It is mainly used to call a method or constructor in the parent class from the subclass.
  It is also used to access the parent class's instance variables or methods that have been hidden by a subclass.

  Uses:
  Refers to the immediate parent class instance variable.
  Can be used to invoke immediateparent class method(eg.  super.methodOfParentClas();)
  can be used to invoke immediate parent class constuctor(eg: super(); )



"this" keyword:
  It is reference variable which refers to current object
  "this" keyword is used to refer to the current instance of the class.

  Uses:
  It is mainly used to differentiate between instance variables and local variables that have the same name.
  Can be usdd to invoke current class constructor
  It is also used to call a constructor from another constructor in the same class(Eg: this(); -> calls default constructor, this(10); -> calls parameterized constructor)
  Can be used to invoke cuurent class methods
  can be used to pass as an argument in method call
  Can be used to pass as an argument in the constructor call.
  Can be used to to return class instance from method(Eg: return this)


Rules of overriding and overloading of methods
  Method Overriding:

  The method in the subclass must have the same method signature (method name, parameters, return type) as the method in the superclass that is being overridden.
  The access level of the overriding method cannot be more restrictive than the access level of the method being overridden.
  The overriding method can throw the same or a subclass of the exception thrown by the overridden method. It can also choose not to throw any exception.
  The overriding method cannot be declared as final or static.
  The return type of the overriding method can be the same or a subclass of the return type of the overridden method.

  Method Overloading:

  The method name must be the same as the method being overloaded.
  The method must have a different parameter list than the method being overloaded. The parameter list can differ in terms of the number of parameters and/or the data types of the parameters.
  The return type of the method can be the same or different than the return type of the method being overloaded.
  The access level and exception thrown by the method can be different than the method being overloaded.


Association:
  Association is a relationship between two classes where an object of one class is related to an object of another class. The relationship can be one-to-one, one-to-many, or many-to-many. The two classes are not dependent on each other and can exist independently. For example, a teacher has an association with a class or a student has an association with a school.

Aggregation:
  Aggregation is a type of association where one class has a reference to another class, but the second class can exist independently of the first class. In other words, the second class is not a part of the first class. Aggregation is also known as a "has-a" relationship. For example, a university has an aggregation relationship with departments, where a department can exist independently of the university.

Composition:
  Composition is a type of aggregation where one class contains another class as a part. The contained class cannot exist independently of the containing class. Composition is also known as a "part-of" relationship. For example, a car has a composition relationship with an engine, where the engine is a part of the car and cannot exist independently.


Can a class be static ?
  In Java, a class can be declared as static only if it is an inner class. An inner class is a class that is defined within another class.
  An inner class can also be inside a method which is called local inner class which is only accessible inside the method in which it is declared.
  3 types of inner class
    Non Static
    Static
    Local inner class
  reason to make inner class static
    To make it independent of its outer class instance.
    To allow it to be used as a regular top-level class.
    To allow it to access the private members of its outer class.

Why we get two class files if one file has two classes ?
  When you compile a Java source file using the javac command, it generates one class file for each class that is defined in the source file. So, if your Java source file contains two classes, then two class files will be generated after compilation.
  The reason for this is that Java follows a strict one-class-per-file policy. This means that each Java source file can only contain one public class, and the name of that class must match the name of the file. If the source file contains additional non-public classes, they can be defined in the same file as the public class, but they must not be accessed from outside the file.
  For example, suppose you have a Java source file named MyClasses.java that defines two classes, ClassA and ClassB.
  After compiling this file with javac MyClasses.java, you will end up with two class files: ClassA.class and ClassB.class.
  The reason for separating each class into its own class file is to make it easier to reuse code in other programs. When you compile a Java source file, you can choose to compile only the classes that have changed since the last compilation, which saves time and makes the build process more efficient. Additionally, separating each class into its own file makes it easier to distribute and share code, since each class can be compiled and packaged separately.

Abstraction
  Data hiding
  can be achieved abstraction using two ways
  1. Abstract Class, Abstract methods
  2. Interface

  

Abstract Class
  If any class has abstract method that class must be abstract.
  It is not compulsory that every abstract class has abstract methods.
  If a class inherits abstract class then it is compulsory to implement all then abstract methods from abstract class
  we cannot create an object of abstract class, but we can create its reference.

Abstract methods
  The method which doesn't have implementation must me abstract.
  Abstract methods are meant to be overriden otherwise it will throw compile time error will be thrown

Interfaces
  It is a blueprint of a class. It specify what a class must do and not how.
  Used to achieve Abstraction
  It supports multiple inheritance
  we can achieve multiple inheritance by extending one or more interfaces to a class
  One interface and class can exetend more than one interface.
  It can be used to achieve loose coupling
  we cannot create the object of interface.
  from 8th version of java we can implement defualt concrete methods and static method in interfaces.
  from 9th version of java we can also implement private methods.
  we must implement all the methods of the interface in a class, which extends the a that interface.
  while overridding the methods of interface we should follow the rules of overriding.

  Syntax:
  interface interfaceName
  {
    Methods  //are automatically public and abstract
    
    fields //by default they are public static final
  }

Upcasting and Downcasting
  Upcasting:
  it means converting an instance of subclass into its parent type reference variable/object.
  Creating reference variable of parent class and instance of child class
  By doing this we can access the attributes and methods of parent class, but we cannot access the attributes of child class, we can only access the the overriden methods of child class. 

  Example : Animal animal = new Dog();
  Creating reference variable of parent class and instance of child class

  Downcasting:
  it means converting an instance of superclass into its child type reference variable/object

  Example : Dog dog=(Dog)animal;


Java executables 
  
  java - The Java Virtual Machine (JVM) executable, which is used to execute Java applications. When you run a Java application with the java command, the JVM reads the compiled Java bytecode and executes it.

  javac - The Java compiler executable, which is used to compile Java source code into bytecode that can be executed by the JVM. When you compile a Java source file with the javac command, it generates one class file for each class that is defined in the source file.

  jar - The Java Archive tool, which is used to package Java class files and related resources into a single compressed archive file. JAR files are used to distribute Java applications and libraries.

  javadoc - The Java documentation generator, which is used to generate API documentation from Java source code. The javadoc command reads the source code and generates HTML documentation files that can be viewed in a web browser.

  jdb - The Java Debugger, which is used to debug Java programs. The jdb command allows you to set breakpoints, step through code, inspect variables, and perform other debugging tasks.

  jps - The Java Virtual Machine Process Status tool, which is used to list the Java processes running on a machine. The jps command is useful for monitoring and managing Java applications.

  jstat - The Java Virtual Machine Statistics Monitoring tool, which is used to monitor the performance of a running Java application. The jstat command can be used to monitor various JVM statistics, such as memory usage, garbage collection, and thread activity.

  jrunscript - The Java Scripting tool, which is used to execute scripts written in various scripting languages, such as JavaScript and Python, on the JVM. The jrunscript command provides a convenient way to execute scripts and interact with Java objects from the command line.

  These are some of the main Java executables and their uses. There are many other Java tools and utilities available for various tasks, such as profiling, testing, and building Java applications.


can we use .equals() for primitive data in java?
  we cannot use the .equals() method for primitive data types in Java. The .equals() method is defined in the Object class, which is the base class for all classes in Java. The method is used to compare the contents of two objects for equality.
  However, primitive data types in Java (such as int, float, and boolean) are not objects, but rather basic data types built into the language. They do not have methods and cannot be compared with .equals(). Instead, you can use the == operator to compare primitive data types for equality.

Final Variables:
  A final variable is a variable that cannot be changed once it has been assigned a value. Once a final variable is initialized, its value cannot be modified. Final variables are commonly used to declare constants in Java programs.

Final Methods:
  A final method is a method that cannot be overridden by a subclass. Once a method is declared final, it cannot be modified or overridden by any subclass.

Final Classes:
  A final class is a class that cannot be extended by any subclass. Once a class is declared final, it cannot be subclassed. Final classes are often used for security reasons, to prevent other developers from modifying or extending critical classes in a program.

Functional interface
  In Java, a functional interface is an interface that has only one abstract method. Functional interfaces are often used to represent lambda expressions or method references, which are key features of Java 8's functional programming capabilities.

  EX:

  @FunctionalInterface
  public interface MyFunction {
    int apply(int x, int y);
  }

  In this example, MyFunction is a functional interface with one abstract method called "apply". This method takes two integer arguments and returns an integer result. The "@FunctionalInterface" annotation is used to mark this interface as a functional interface, which is not required but recommended as a convention.

  Functional interfaces can be implemented using lambda expressions, as shown in this example:

  public static void main(String[] args) {
    MyFunction addFunction = (x, y) -> x + y;
    MyFunction multiplyFunction = (x, y) -> x * y;
    
    int result1 = addFunction.apply(2, 3);
    int result2 = multiplyFunction.apply(2, 3);
    
    System.out.println(result1); // Output: 5
    System.out.println(result2); // Output: 6
  }

New features of java 8

  Default Methods:
  Default methods allow us to add new behavior to interfaces without breaking existing implementations. A default method is a method that has a default implementation in the interface itself.

  Static Methods:
  Static methods allow us to add utility methods to interfaces without requiring an instance of the interface. A static method is a method that has a static keyword in the method signature.

  Functional Interfaces:
  Functional interfaces are interfaces that have only one abstract method. Functional interfaces are used as the basis for lambda expressions, which are a key feature of Java's functional programming capabilities.
  
Arrays

Enumerations

  In Java, an enumeration is a special type of class that represents a fixed set of values, known as enumeration constants. Enumeration constants are usually used to represent a collection of related constants, such as days of the week or colors.

  eg:

  public enum DayOfWeek {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
  }

  Methods and Fields

Packages in java

  In Java, a package is a way to organize related classes and interfaces into a single unit of code. Packages are used to avoid naming conflicts, improve code readability, and to provide access protection.
  Ex:
  package com.example.myapp;

Import statements

  The import statement is used to bring classes from other packages into your own code.
  import java.util.ArrayList;

Static import
   static imports allow you to access static members (i.e., fields and methods) of a class without having to prefix them with the class name. This can make your code more concise and readable, particularly if you are using static members from the same class multiple times.
  
Constructor chaining

  Constructor chaining is the process of calling one constructor from another constructor within the same class or between classes. This is a useful technique for reducing code duplication and improving code maintainability, particularly in situations where multiple constructors share common functionality.

Explain Accessing protected variables and methods outside the package

  The protected access modifier can be applied to class members (fields, methods, and nested classes) to make them accessible within the same package as well as within subclasses outside the package. However, accessing protected members outside the package requires some additional rules to be followed.
  Here are the rules for accessing protected members outside the package:
  1. A subclass outside the package can access the protected members of its parent class using a reference to an object of the subclass type.
  2. A subclass outside the package can access the protected members of its parent class using the super keyword within the subclass.
  3. A non-subclass outside the package cannot access the protected members of a class.

Garbage collection
  Garbage collection in Java is the process of automatically freeing memory that is no longer being used by the program. When an object is created in Java, it is allocated memory on the heap. When the object is no longer being referenced by the program, the memory is freed up by the garbage collector.

  The garbage collector runs in the background and periodically scans the heap for objects that are no longer being referenced by the program. It then frees up the memory used by those objects so that it can be reused by the program.

  It's worth noting that the garbage collector in Java is a complex process that can vary between different implementations and versions of Java. While it provides automatic memory management and can improve the performance and stability of Java programs, it can also introduce some overhead and may not be suitable for certain types of applications.

Requesting JVM to run garbage collection
   you can request the JVM to run garbage collection explicitly by calling the System.gc() method. This method is a request to the JVM to run the garbage collector, but it does not guarantee that the garbage collector will actually run at that moment.
   It's worth noting that requesting the garbage collector to run explicitly is generally not recommended, as the JVM is designed to manage memory automatically and efficiently. However, there may be certain cases where you need to manually trigger garbage collection, such as when working with large objects or running on a memory-constrained environment.

Different ways to make object eligible for garbage collection

  1. Nulling a reference variable: When a reference variable no longer points to an object, that object becomes eligible for garbage collection. This is achieved by assigning null to the reference variable.
  Eg:
    MyClass obj = new MyClass();
    // use obj
    obj = null; // obj no longer points to the object created earlier, making it eligible for garbage collection


  2. Re-assigning a reference variable: When a reference variable points to a different object, the previous object it pointed to becomes eligible for garbage collection.
  Eg:
    MyClass obj1 = new MyClass();
    // use obj1
    MyClass obj2 = new MyClass(); // obj1 now points to a new object, making the previous object eligible for garbage collection


  3. Island of Isolation: When a group of objects references each other, but there are no external references to the group, they become isolated and eligible for garbage collection.
  Eg:
    public class MyClass {
        private MyClass next;
        public void setNext(MyClass next) {
          this.next = next;
        }
    }
    // create a chain of objects that reference each other
    MyClass obj1 = new MyClass();
    MyClass obj2 = new MyClass();
    MyClass obj3 = new MyClass();
    obj1.setNext(obj2);
    obj2.setNext(obj3);
    obj3.setNext(obj1);
    // the entire chain of objects is now isolated and eligible for garbage collection

Finalize()
  the finalize() method is a special method that is called by the garbage collector before an object is removed from memory. This method can be overridden by the user to provide custom cleanup logic for the object.
  When an object of MyClass is no longer being used by the program and becomes eligible for garbage collection, the finalize() method will be called by the garbage collector before the object is removed from memory. In this method, we can perform any cleanup logic we need, such as closing resources or releasing locks.
  It's worth noting that the finalize() method is not guaranteed to be called by the garbage collector, and its use is discouraged in modern Java programming. Instead, it's recommended to use try-with-resources or similar constructs to ensure that resources are properly cleaned up.

Wrapper classes
   wrapper classes are used to convert primitive data types into objects. The wrapper classes provide a way to use primitive data types as objects, and they also provide methods for performing various operations on these objects.

    There are eight wrapper classes in Java, one for each primitive data type. These classes are:

    Integer
    Long
    Float
    Double
    Boolean
    Byte
    Short
    Character
    Wrapper classes are useful when we need to use primitive data types in a context where objects are required. For example, when working with collections or when passing values as arguments to methods that expect objects.

String class
    The String class in Java is used to represent a sequence of characters. Strings in Java are immutable, which means that once a string is created, it cannot be changed. When you modify a string, a new string is created in memory

String Constant Pool
  SCP is a memory area in heap
  Till 1.6 version string pool was in method area 
  Now its in Heap area

  String s = new String("Siddhant");  -> creates 2 objects, one in heap(Siddhant) and one in SCP(Siddhant) it is created by JVM using a reference variable that is created automatically and it is never deleted by garbage collector.
  String s = "Rahul";    -> creates only one object i.e in SCP(Rahul) 
  There will be no same literals in SCP


StringBuffer
    The StringBuffer class in Java is used to represent a mutable sequence of characters. Unlike strings, string buffers can be modified in-place without creating new objects
    Because string buffers are mutable, they are not thread-safe. This means that if multiple threads access the same string buffer object at the same time, there is a risk of the buffer being modified unexpectedly. To avoid this, you can use synchronization to ensure that only one thread can access the buffer at a time.

StringBuilder
    The StringBuilder class in Java is similar to the StringBuffer class, in that it is used to represent a mutable sequence of characters. However, unlike StringBuffer, StringBuilder is not thread-safe. This makes it faster and more efficient than StringBuffer, but also means that you need to be careful when using it in a multi-threaded environment.
    Because StringBuilder is not thread-safe, it should only be used in situations where you know that only one thread will be accessing the object at a time.

Autoboxing and Unboxing
  Autoboxing:
  automatic conversion of premitive data type into object 

  eg:
  int x=5;
  Integer j = Integer.valueOf(i);   // manual conversion of premitive data type into object 
  Integer y = i;                    // autoboxing, in this automaticaly JVM writes Integer.valueOf(i)

  Unboxing:
  reverse operation, converting an Object back to primitive datatype.
  
  Eg:
  Integer iobj = new Integer(100);
  int i = iobj.intvalue();        //manual convertion an Object back to primitive datatype
  int i = iobj;                   //unboxing, in this automaticaly JVM writes iobj.intvalue()
  


  

Exception hierarchy
  diagram in imgage folder

Exception Handling

  Unchecked -> The exception that cannot be checked by compiler. Program will compile but will terminate after exception if we don't use try catch or throws keyword.

  Exceptions occur only in runtime.

  try: has code that can throw exception
    if the exception is occured in the try block and it is handled by catch, then the code under the line on which exception has occured will not be executed.

  catch: has code to handle the exception
         
         methods to handle exception:
         e.printStackTrace()  it prints name description and stacktrace
         sopln(e) or e.toString()  doesn't give stack trace
         e.getMassage() only showes description

  finaly: compulsory executes after try block
          can be written with only try block
          cannot be written solo
          used for writting cleanup code(closing connections with resourses)

          conditions when finaly doesn't executes:
          System.exit() in try
          error in try block
          exception in finaly itself

  throw: used to create exception object by programmer directly to jvm without interferance of method in which exception occur.
         syntax -> throw new exceptionClassName("massage for exception ");
         mainly used to throw custom/user defined exception 
         if we want to create a custom checked exception class it should extend Exception class
         if we want to create a custom unchecked exception class it should extend RuntimeException class
         mainly we should create custom uncheked exeption class but we can create both.
         we cannot write any statement after throw it does'nt executes. 

  Throws: while defining a function it showes that this method can show a perticular exception, which should be handled in caller method.
         only used for checked exception i.e compile time exception.
         syntax ->  void methodName() throws ArithmaticException 

  exception object: it has name, description, stack trace of exception



Exception propagation
  Exception propagation refers to the process of passing an exception from one method to another in Java. When an exception is thrown in a method, it can be caught and handled in the same method, or it can be propagated up the call stack to be caught and handled by a calling method.

serialization
  Serialization is the process of converting an object into a stream of bytes, which can then be stored or transmitted over a network. Deserialization is the reverse process of reconstructing the object from the serialized bytes.

  Conditions for serialization
    The class should impliment serializable interface which is marker interface.
    All fields should be serializable. If a field is not serializable is should be marked transient.
    field should not be static.

  for serialization ObjectOutputStream which consist of method "writeObject" 
  for deserialization ObjectInputStream which consist of method "readObject"

  The file should be .ser extension in which we are going to store byte data 

  In Java, the Serializable interface is used to mark a class as serializable. When an object of a serializable class is serialized, its instance variables are written to a stream in a specific order, along with some metadata that identifies the class and its version. The resulting stream of bytes can be stored in a file or transmitted over a network.

deserialization

InputStream, OutputStream, Reader and Writer interfaces

Shallow copy
  object cloning is the process of creating a new object with the same values as an existing object. There are two types of cloning: shallow cloning and deep cloning.

  Shallow copy refers to the process of creating a new object that has an exact copy of the values in the original object, but the references to objects inside the original object are still the same as the original object. In other words, if the original object contains references to other objects, then the shallow copy will also contain references to the same objects.

Deep copy
  Deep copy, on the other hand, refers to the process of creating a new object that has an exact copy of the values in the original object, including the references to objects inside the original object. In other words, if the original object contains references to other objects, then the deep copy will also create new objects for each of these references.
  Note that when creating a deep copy of an object, all referenced objects must also be deeply copied. This can be a complex and error-prone process, especially when dealing with complex object graphs.
  It is also important to note that not all objects can be cloned. Only objects that implement the Cloneable interface can be cloned. Additionally, the clone() method is a protected method, so it can only be called from within the same package or from a subclass. Therefore, it is not a commonly used technique in Java, and alternative approaches such as copy constructors or factory methods are often preferred.

Date class
  The java.util.Date class represents a specific moment in time, with millisecond precision. However, it has several issues that make it less than ideal for working with dates and times, such as:
  It is mutable, which can lead to subtle bugs in multi-threaded environments.
  It has no time zone information, which can lead to ambiguity when comparing dates and times across time zones.
  It is a legacy class and has been replaced by the java.time package in Java 8 and later versions.

Calendar
  The java.util.Calendar class provides a way to manipulate dates and times in a more flexible and sophisticated way than the Date class. It supports many different calendars and time zones, and provides methods for adding and subtracting units of time such as days, hours, and minutes.

DateTime
  The java.time package was introduced in Java 8 as a replacement for the Date and Calendar classes. It provides a more comprehensive set of classes for representing dates and times, including the LocalDate, LocalTime, and LocalDateTime classes for representing dates and times without time zone information, and the ZonedDateTime class for representing dates and times with time zone information.

Overriding toString, equals and hashcode
  the Object class provides a few methods that are important for any class to implement. These methods include toString(), equals(), and hashCode(). While the default implementation of these methods provided by Object is sufficient for some cases, it is often necessary to override them in your own classes to ensure proper behavior. Here's an explanation of how to override these methods in Java:

  toString()
  The toString() method is used to convert an object to a string representation. By default, the toString() method provided by Object returns a string that consists of the class name followed by the memory address of the object in hexadecimal format. However, this default implementation is not very useful, so it is often necessary to override it in your own classes to provide a more meaningful string representation.
  To override the toString() method, simply define a new implementation in your class. 

  equals()
  The equals() method is used to determine whether two objects are equal. By default, the equals() method provided by Object checks whether two objects are the same object (i.e., whether they have the same memory address). However, this default implementation is not always appropriate, as two different objects may be considered equal based on some criteria.
  To override the equals() method, you should define a new implementation that checks whether two objects are equal based on some criteria. Typically, this involves comparing the values of the object's fields.

  hashCode()
  The hashCode() method is used to generate a hash code for an object. Hash codes are used by some data structures (such as hash maps and hash sets) to quickly locate objects. By default, the hashCode() method provided by Object returns a hash code based on the memory address of the object. However, this default implementation is not always appropriate, as two equal objects should have the same hash code.
  To override the hashCode() method, you should define a new implementation that generates a hash code based on some criteria. Typically, this involves generating a hash code based on the values of the object's fields

Collections

Multitasking 
  performing multiple tasks at single time
  increases performance
  can be achieved using multithreading and multiprocessing.

Multithreading
  Executing multiple threads at single time. 
  most suitable at programming level
  provides predefinde API

multiprocessing
  When one system is connected to multiple processor in order to complete the task.
  best suitable at system lavel.

diff bet Process and thread
  process
    a program which executes task
    heavy weight
    takes more time in context switching
    slow communication
    each process has different address space
    not dependent on other process
    not require synchronization
    uses more resource consumption

  thread
    a sub part of process
    light weight
    takes less time in context switching
    fast communication
    each thread has same address space in a process
    dependent on other treads
    may require synchronization
    uses less resource consumption

ways to create thread
  1.Thread class
     has constructors and methods.
     present in java.lang package
     
     steps to create:
     class should extend Thread class
     override run method
     write a task in run() method
     to start a thread in main method we have to create an object and use start() method(eg: obj.start())
     JVM allocates processor to thread using threadSchedular

    Thread lifecycle
      create
      Runnable
      Running
      Non runnable state
      Dead state

    Ex
    class Test extends Thread
    {
      public void run()
      {
        Sop("Thread task");
      }

      PSVM()
      {
        Test t = new Test();
        t.start();
      }
    }

  2.Runnable interface
    It is a interface present in java.lang package has only one method i.e run()
    Thread class implements Runnable interface
    Its better than 1st way because if a class will not be able extend Thread class wants to extend another class because java doesnt support multiple inheritance

    Steps to create:
    implement the Runable Interface
    Override the run Method
    Create Object Of The Class Which Implements this interface
    then create a Thread class's object
    and pass the main classes object into Thread classes constructor.
    and then start() a thread using Thread class's object. 

    Ex
    class Test implements Runnable
    {
      public void run()
      {
        Sop("Thread task");
      }

      PSVM()
      {
        Test t = new Test();

        Thread th = new Thread(t);
        th.start();
      }
    }

while creating a thread JVM first creats the thread of main method.

Performing single task from single thread
  creating one task(run()) and one object

performing single task from mutiple thread
  creating one task(run()) and multiple objects

Performing multiple task from single thread
  Not possible

Performing multiple task from multiple thread
   creating multiple tasks i.e run method in multiple classes and creating thier objects. 


Constructors of Thread class
  default constructor -> Thread()
  Parametrized   -> Thread(Runnable target)
  parametrized with name-> Thread(String name)
  parametrized with name-> Thread(Runnable target,String name)
  Thread(Threadgroup tg, Runnable target)
  Thread(ThreadGroup group, String name)
  Thread(ThreadGroup g, Runnable r, String n)
  Thread(ThreadGroup group, Runnable target, String name)
  Thread(ThreadGroup group, Runnable target, String name, long stackSize)


Methods of Thread Class
  1) run(), start(), currentThread(), isAlive()
  2) getName(), setName(String name)
  3) isDeamon(), setDeamon(boolean b)
  4) getPriority(),setPriority(int p),getPriorityLevel()
  5) sleep(), join(), yield()
  6) interrupt(), isInterrupted(), interrupted()

Inter Thread communication
  wait(), notify(), notifyAll() -> these all are present in object class

Naming a Thread
  getting a name of thread 
    Sop(Thread.currentThread().getName());

  setting a name of thread 
    Thread.currentThread().setName("Sidd");
  
Daemon Thread
  Which runs in the background
  Used to provide service to the thread(eg: gc, spellchecker)
  By Default daemons are false for every new threads created by JVM
  But we can change it using method setDaemon(true/false).
  Its life depends on the main thread on the background which it runs
  If parent thread is daemon then child is daemon by defualt.
  Most of the time daemon threads priority should be less.
  Unless a parent thread performs any task daemon will not start.

  Case 1:
    We have to create daemon thread before starting thread.
  Case 2:
    we cannot create main thread as daemon
  
  Methods:
    setDaemon(Boolean b)
    isDaemon()
  
  Ex:
  Class Test extends Thread
  {
    public void run()
    {
      sop("Child Thread");
    }

    PSVM(String[] args)
    {
      sop("main Thread");
      Test t =new Test();
      t.setDaemon(True);
      t.start();
    }
  }
  
Thread Priority

  JVM provides the priority to each thread and allocate the processor according to it.
  It is integer value 1 - 10
  A thread having high value gets first priority
  The default values assigned to all threads are same i.e.,5 (norm priority)
  Priorities are inherited by parent thread
  main threads priority is 5
  Windows does'nt support priorities.

  Methods:
  setPriority(): sets priority of this thread
  getPriority(): returns current priority level 
    int getMaxPriority(): Returns maximum possible priority level allowed

Prevent Thread execution Methods:
Sleep()
  Working:
  This method suspends a currently executing thread for specified time in milliseconds(0-999999).
  should be written in try block.
  Syntax:
  ex: currentThread.sleep(1000);

  Prototypes: 
  1) public static native void sleep(long millisec) throws Interruptedxception  -> written in another language  
  2) public final void sleep(long millisec, int name)throws InterruptedException -> written in java  

yield()
  Working:
  stops the current executing thread and give a chance to other thread for execution that has higher or same priority.
  Thread provides the hint to the thread-schedular, then it depends on thread-schedular to accept on ignore the hint.
  Output may vary
  Yields control back to other waiting or runnable threads if any exist within its own thread group

  Syntax:
  ex: Thread.yield();

  Prototype:
  1)public static native void yield();

join()
  Wroking:
  if a thread wants to want to wait for another thread to complete its task, then we should use join() method.
  waits until another thread terminates or dies.

  syntax:
  t1.join(); //t1 is thread that will execute and the thread in which t1.join() in written will stop

  Prototype:
  1) public final void join() throws InterruptedException 
  2) public final synchronized join(long millis)
  3) public final synchronized join(long millis,int nanos)

Thread interrupt in java
  Used to to interrupt an executing thread.
  interrupt() method will only works when the thread is in sleeping or waiting state(sleep() or wait()).
  If a thread is not in sleeping or waiting state then calling the interrupt() method will perform normal behavior.
  To check whether the thread has been interrupted use interruped() method of Thread class.
  interrupt() throws InterruptedException

  prtotype:
  public void interrupt()

  syntax:
  t.interrupt();

  Methods:
  interrupted():
  Used to check whether the thread is interrupted or not.
  returns true if this thread was interrupted by some other thread while it was blocked in a particular monitor lock operation then false otherwise.
  clears the interrupted from true to false if thread is interrupted(also used to stop the interruption)
  Prototype:
  1) public static boolean interrupted()

  isInterrupted():
  Used to check whether the thread is interrupted or not.
  returns boolean value if it's true then its means the thread was interrupted else no.
  does'nt clears the interrupted from true to false if thread is interrupted.
  Prototype:
  1) public boolean isinterupted()

Synchronization
  It is a process through which we control the accessiblity of multiple thread to a particular shared resource
  Synchronization allows one object (thread/process etc.) access a resource at any given time by ensuring mutual exclusion between threads accessing same resources.
  Problems if we don't use synchronization:
  - Data corruption/inconsistency
  - Deadlock (when two threads are blocked on each other).

  package used:
    import java.util.concurrent;
  
  Syntax:
  synchronized void methodName()
  {
    //code
  }

  synchronized block:
   
  The code inside a synchronized block can be executed by only one thread at any given time, even though multiple methods may execute concurrently in different parts of your program. This ensures that all changes though multiple threads may have entered this method simultaneously and tried to acquire lock.
  Synchronized methods in Java provide mutual exclusion of access for all invocations within that particular 
  object instance. This ensures data integrity as well as avoids deadlocks between different objects.
  The keyword "synchronized" can be applied at method level, class-level and even a statement

  Syntax:
  synchronized(objectReference){
    code
    }
    Example:
    private int count =0 ;
    synchronized(this){
      this.count++;
      }
      System.out.println("Count:"+this.count);
      Output : Count:2
      Note:- If you want to synchronize multiple statements or blocks inside your program
      then instead using synchronized keyword with an Object reference You should wrap the entire group of statements into one single synchronized block
      
Static synchronization
  Using this the shared resource will be common for all objects.

  Problem that is solves:
  Static variables may not have the same value across instances because they're shared amongst them.
  Solution:
  Use static synchronisation when there's only one copy of an object being created by JVM.
  How it works:

Interthread communication
  Inter thread communication is a mechanism in which a thread releases the lock and enters into paused state and another thread acquires the lock and continue to execute.
  These methods are from Object class and not Thread class. 
  methods:
  wait():
  It suspends execution until another thread invokes the notify() or notifyall()method on the current object (the calling thread).

  notify():
  




  notifyAll():

Reflections
  It alows us to inspect and manipulate classes, interface, constructor, methods and fields at run time.
  Reflection provides dynamic access to runtime information about classes through its API.
  Its in java.lang.reflect
  Basically there are some methods in "Class" class by which we can get name, methods, fields, parent class.
  we can also use it to change the private final fields of a class(by doing the field.accessible(true))
  refer program 






